\documentclass[10pt, hyperref={pdfpagelabels=false}]{beamer}

\usepackage{tikz, verbatim, enumitem}

\usetikzlibrary{decorations}
\usetikzlibrary{backgrounds}
\usetikzlibrary{patterns}
\usetikzlibrary{snakes}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning, shapes.geometric, arrows.meta}
\usetikzlibrary{arrows,automata}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1.3ex}

\title{Encryption:\\The ChaCha20 Symmetric Stream Cipher}
\author{Michael Brockway}
\date{\today}

\setlist[enumerate]{itemsep=0mm}
\setitemize{label=\usebeamerfont*{itemize item}
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Overview}
Transport-layer security employs an asymmetric public cryptosystem to allow two paries (usually a client application and a server) to authenticate each other and negotiate, among other things, a shared key for use in a symmetric cryptosystem for fast data encryption.

An example public-key system will be outlined in another lecture.

The present lecture gives an example of a fast symmetric system.
\begin{itemize}
\item \emph{AES} (advanced encryption standard, \emph{Rijndael} has been the symmetric system of choice in TLS some years now. Its design and implmentation are somewhat technical (mathematically and computationally) but a link to some notes about it are given in the FutherRead section at the end.
\item \emph{ChaCha20} is a recently devloped \emph{stream cipher} approved for use in TLS and is straightforward to describe in a single lecture.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Block versus Stream Ciphers}
These are two design philosopies for ciphers. A block cipher 
\begin{itemize}
\item divides the plain- or cipher-text into \emph{blocks} of a fixed number of bytes.
\item The algorithm defines a function (dependent on a \emph{round key}) to encrypt a block, usually iterating this over several \emph{rounds}.
\item The round keys are derived from the master key by a \emph{key scheduling} algorithm.
\item The cipher operates on the text as a sequence of blocks. The algorithm for encrypting a block generally depends in some way on the output of encryption of the previous block.
\item Encryption and decryption both work like this.
\item AES (Rijndael) is built like this. The first item in `further reading' gives an example. One round of processing of a block involves applying four helper functions one after the other. They are invertible, and decryption consists in applying the inverse functions in reverse order.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Block versus Stream Ciphers}
A stream cipher
\begin{itemize}
\item does not block the input, but just works on the text as a \emph{stream} of bytes.
\item A common approach is, given a \emph{key} and an \emph{initial vector} (a short sequence of bytes) to generate a long stream bytes which look `random' but are not, being entirely determmined by the key and initial vector.
\item In this kind of approach, text is simply XORed bit by bit with the generated byte stream.
\item XORing twice cancels itself out: {\color{blue}$(b~XOR~b')~XOR~b'$} is just {\color{blue}$b$} back again;
\item so a text encrypted in this way can be decrypted be repeating the process using the same key and initial vector.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{XOR (exclusive OR)}
You can check this from the \emph{truth table} of XOR:

\begin{tabular}{c||c|c} 
XOR & 0 & 1 \\
\hline \hline
 0  & 0 & 1 \\
\hline 
 1  & 1 & 0 
\end{tabular}

Alternatively, for any bit $b$, $(b~XOR~0)$ is just $b$ while $(b~XOR~1)$ is $\sim b$.

For efficiency the data streams are generally handled a byte or a \emph{word} at a time: a word is, with modern hardware, 32 or 64 bits. Bitwise XOR of a word is a single machine instruction.
\end{frame}

\begin{frame}
\frametitle{ChaCha20 Overview}
\begin{itemize}
\item Developed by David Bernstein from an earlier cipher, Salsa20.
\item Both ciphers are `ARX': the operations are combinations of addition, rotation of bits, and exclusive-OR.
\item It is claimed that this approach can produce sufficient `mangling' of the input without the need for S-boxes or similar, and as the result, encryption is fast and efficient.
\item The design and implementation of Salsa20 are described by Bernstain in \href{https://cr.yp.to/snuffle/design.pdf}{\textcolor{blue}{design}} [click] and \href{https://cr.yp.to/snuffle/spec.pdf}{\textcolor{blue}{specification}} [click]. The latter is clear enough for anyone to write their own implmentation or Salsa20 - a good programming exercise!
\item ChaCha20 is introduced by Berstein as a development of Salsa \href{https://cr.yp.to/chacha/chacha-20080128.pdf}{\textcolor{blue}{here}} [click]. 
\end{itemize}

The URLs of these papers are listed in `further reading' below where there are also links to local copies. 
\end{frame} 

\begin{frame}
\frametitle{ARX}
The X stands for XOR as above, perfomed bitwise on 32-bit words.
\begin{itemize}
\item Thus 0x48a5d72e XOR 0x234a79bb = 0x6befae95.
\end{itemize}

A is for \emph{addition}. 32-bit words are added as unsigned integers. If the result does not fit into 32 bits, the extra `carry' is discarded: so this is effectively addition modulo $2^{32}$.
\begin{itemize}
\item 0x78a5d72e + 0xf34a79bb = 0x6bf050e9. (Carried 1 discarded.)
\end{itemize}
\end{frame} 

\begin{frame}
\frametitle{ARX}
R is for \emph{rotation}. a 32-bit word can be \emph{rotated} left or right some number of bits. This is like a \emph{shift} but the bit that are shift-out of the register `run around the back' and shift in.

Thus, in binary, the byte \texttt{10110100} rotated left 3 bits ends up as \texttt{10100\color{blue}101}. The {\color{blue}blue} bits ran around the back.

Rotations work similarly with (unsigned) shorts, ints (words), longs. They can be defined in terms of shifts:
\begin{itemize}
\item left-rotation of $x$ by $n$ bits is \texttt{(x << n) | (x >> (w-n))}
\item right-rotation of $x$ by $n$ bits is \texttt{(x >> n) | (x << (w-n))}
\item $w$ is the width: 32 for 32-bit words. 
\item These are \emph{logical} shifts. In java you would use \texttt{>>>} rather than \texttt{>>}. 
\end{itemize}

0x78a5d72e ...
\begin{itemize}
\item rotated left 7 bits is 0x52eb973c;
\item rotated right 13 bits is b973c52e.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ChaCha20}
The cipher, the form used in transport-layer security, is described in detail in \href{https://tools.ietf.org/html/rfc7539}{\textcolor{blue}{RfC 7539}}[click] see sections 2.1 -- 2.4.

Although it is a \emph{stream} cipher, the algorithm actually generates the stream 64 bytes at a time, and encrypts a stream of bytes 64 at a time by XORing with these, generating another lot of 64 bytes as it needs to. Do not be distracted with the term `block' in the literature!

The data is handled internally in 32-bit words (unsigned integers), 16 words (64 bytes) at a time. 
\begin{itemize}
\item A \emph{\color{blue}state} of the cipher is an array of 16 words
\end{itemize}

The `20' signifies that the cipher runs in 20 rounds.
\begin{itemize}
\item The basic `unit' the the algorithm is the \emph{\color{blue}quarter-round},
\item Four of these are combined to make a \emph{\color{blue}column-round}
\item and four are combined in another way to make a \emph{\color{blue}diagonal-round}.
\item Ten column-rounds alternate with ten diagonal-rounds to make 20 \emph{rounds}.
\end{itemize}
\end{frame}

\begin{frame} [fragile]
\frametitle{ChaCha20 Quarter-round}
The basic function is
{\color{blue}
\begin{verbatim}
void quarterround(word * a, word * b, word * c, word * d) {
  *a += *b; *d ^= *a; *d = lRot(*d,16);
  *c += *d; *b ^= *c; *b = lRot(*b,12);
  *a += *b; *d ^= *a; *d = lRot(*d, 8);
  *c += *d; *b ^= *c; *b = lRot(*b, 7);
}
\end{verbatim}
}
Four words pointed at by a, b, c, d are updated by an ARX combination of additions, XORs and left-rotations. 

This function is applied to a state (array of 16 words) by picking four indexes into the array to serve as quarter-round parameters:
{\color{blue}
\begin{verbatim}
void qrOnState(word * state, int h, int i, int j, int k) {
  quarterround(state+h, state+i, state+j, state+k);
}
\end{verbatim}
}
\end{frame}

\begin{frame} [fragile]
\frametitle{Column-Quarter-round}
ChaCha applies this function to a state in two different ways. First, the column-round:
{\color{blue}
\begin{verbatim}
void columnRound(word * state) {
  qrOnState(state, 0, 4,  8, 12);
  qrOnState(state, 1, 5,  9, 13);
  qrOnState(state, 2, 6, 10, 14);
  qrOnState(state, 3, 7, 11, 15);
}
\end{verbatim}
}
Think of the state as\\
\begin{tabular}{c c c c} 
s[0] & s[1] & s[2] & s[3]\\
s[4] & s[5] & s[6] & s[7]\\
s[8] & s[9] & s[10] & s[11]\\
s[12] & s[12] & s[14] & s[15]\\
\end{tabular}

and you may see why this is called `column-round'
\end{frame}

\begin{frame} [fragile]
\frametitle{Diagonal-Quarter-round; Double-Round}
The diagonal-round is, similarly,

{\color{blue}
\begin{verbatim}
void diagRound(word * state) {
  qrOnState(state, 0, 5, 10, 15);
  qrOnState(state, 1, 6, 11, 12);
  qrOnState(state, 2, 7,  8, 13);
  qrOnState(state, 3, 4,  9, 14);
}
\end{verbatim}
}
(Can you relate this to the 4x4 picture of a state?)

Now a \emph{double-round} is
{\color{blue}
\begin{verbatim}
void doubleRound(word * state) { 
  columnRound(state);
  diagRound(state);
}
\end{verbatim}
}

8 quarter-rounds = a double-round.\\
ChaCha20 runs 10 iterations of this on a state (hence 20 rounds).
\end{frame}

\begin{frame}
\frametitle{ChaCha20 state initialisation}
\begin{itemize}
\item A 32-byte \emph{key} and a 12-byte \emph{initial vector} (\emph{nonce}) are provided as arrays of bytes.
\item These are converted to arrays of 8 (32-bit, 4-byte) words and 3 words resectively: each 4 bytes makes a word  in \emph{little-endian fashion}.
\end{itemize}

The \emph{initial state} is the built thus
\begin{itemize}
\item state[0..3] are word-size constants \\\texttt{\color{blue}0x61707865, 0x3320646e, 0x79622d32, 0x6b206574};
\item state[4..11] are are the key derived from the little-endian byte array;
\item state[12] is a word-sized \emph{block counter}. Typically it is set to 1 at the beginning and incremented every time the algorithm is required to generate another output block.
\item state[13..15] are the initial vector derived from the little-endian byte array.
\end{itemize}
\end{frame}

\begin{frame} [fragile]
\frametitle{ChaCha20 block function}
{\color{green!20!black!80} \small
\begin{verbatim}
void chaCha20Block(byte* key, byte* nonce, word blkCt, byte* output) {
  word state[16], state0[16];
  initState(key, nonce, blkCt, state); //initialise the state

  int i;
  for (i=0; i<16; i++)
    state0[i] = state[i];  //... make a copy of the state
  for (i=0; i<10; i++)
    doubleRound(state);    //... do 10 double-rounds

  for (i=0; i<16; i++)     //... add the origianal state word-by-word
    state[i] += state0[i]; 
  
  //convert result to a sequence of 64 bytes for output:  
  for (i=0; i<16; i++)
    invLittleEndian(state[i], output + i*4); 
}
\end{verbatim}
}

NB Initialisation of the state is as on previous slide;\\
Addition is word-wise, mod $2^{32}$.
\end{frame}

\begin{frame}
\frametitle{ChaCha20 block function}
We now have an algorithm which, given a key and an initial vector and a block-count value, will produce an array of 64 bytes: namely the byte-format version of the state after initialisastion and 10 double-rounds.

This will produce a long stream of bytes, if we initialize the block-counter, say, to 1 and iterate, incrementing the block-counter.
\begin{itemize}
\item We get 64 bytes each iteration
\item The block counter can count up to $2^{32}$.
\item $2^{38}$ bytes: 256 GiB
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ChaCha20 encryption}
To encrypt a sequence of up to $2^{38}$ bytes, (given a key and initial vector as above),
\begin{itemize}
\item Initialise block count and generate 64 bytes with the block function;
\item while (there are $\ge 64$ bytes of input text left)
  \begin{itemize}
  \item XOR the next 64 text bytes with these;
  \item increment block count and generate another 64 bytes with the block function.
  \end{itemize}
\item Now there are  $< 64$ text bytes left to do; truncate the generated stream to this number and XOR with the text bytes.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Further reading}
\begin{itemize}
\item A paper On AES/Rijndael, for your interest:\\\texttt{\small\color{blue} http://computing.northumbria.ac.uk/staff/cgmb3/teaching/\\cryptography/RijndaelAES.pdf}
\item Bernstein's paper on design of Salsa20: \\\texttt{\small\color{blue} https://cr.yp.to/snuffle/design.pdf}
\item Bernstein's paper on implmentation of Salsa20: \\\texttt{\small\color{blue} https://cr.yp.to/snuffle/spec.pdf}
\item Bernstein's paper on ChaCha20: \\\texttt{\small\color{blue} https://cr.yp.to/chacha/chacha-20080128.pdf}
\item RfC 7539 on ChaCha as implemented for TLS:  \\\texttt{\small\color{blue} https://tools.ietf.org/html/rfc7539}
\end{itemize}
There are local copies of the Salsa and ChaCha papers at \texttt{\small\color{blue} http://computing.northumbria.ac.uk/staff/cgmb3/teaching/\\cryptography/index\_crypto.html}

ZIPs of the ChaCha implementation discussed in the lecture (and the Salsa implementation) are availble here also.
\end{frame}

\end{document}

